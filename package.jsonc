{
  "name": "nest-admin",
  "version": "2.0.0",
  "private": true,
  "packageManager": "pnpm@9.1.0",
  "license": "MIT",
  "engines": {
    "node": ">=20.0.0",
    "pnpm": ">=9"
  },
  "scripts": {
    "postinstall": "npm run gen-env-types",
    "prebuild": "rimraf dist",
    "build": "nest build",
    "dev": "npm run start",
    "dev:debug": "npm run start:debug",
    "repl": "npm run start -- --entryFile repl",
    "bundle": "rimraf out && npm run build && ncc build dist/main.js -o out -m -t && chmod +x out/index.js",
    "start": "cross-env NODE_ENV=development nest start -w --path tsconfig.json",
    "start:debug": "cross-env NODE_ENV=development nest start --debug --watch",
    "start:prod": "cross-env NODE_ENV=production node dist/main",
    "prod": "cross-env NODE_ENV=production pm2-runtime start ecosystem.config.js",
    "prod:pm2": "cross-env NODE_ENV=production pm2 restart ecosystem.config.js",
    "prod:stop": "pm2 stop ecosystem.config.js",
    "prod:debug": "cross-env NODE_ENV=production nest start --debug --watch",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "doc": "compodoc -p tsconfig.json -s",
    "gen-env-types": "npx tsx scripts/genEnvTypes.ts || true",
    "typeorm": "cross-env NODE_ENV=development typeorm-ts-node-esm -d ./dist/config/database.config.js",
    "migration:create": "npm run typeorm migration:create ./src/migrations/initData",
    "migration:generate": "npm run typeorm migration:generate ./src/migrations/update-table_$(echo $npm_package_version | sed 's/\\./_/g')",
    "migration:run": "npm run typeorm -- migration:run",
    "migration:revert": "npm run typeorm -- migration:revert",
    "cleanlog": "rimraf logs",
    // 构建并启动 Docker 容器
    "docker:build:dev": "docker compose --env-file .env --env-file .env.development up --build",
    "docker:build": "docker compose --env-file .env --env-file .env.production up --build",
    // 使用 --no-build 参数时，Docker Compose 不会进行本地镜像构建。
    // 当本地没有所需镜像时，它会尝试从镜像仓库拉取镜像。若拉取成功则正常启动容器，拉取失败则启动容器的操作会失败
    "docker:up": "docker compose --env-file .env --env-file .env.production up -d --no-build",
    // -f 是 --file 的缩写  指定只使用 docker-compose.prod.yml 配置文件
    // -d 是 --detach 的缩写，该参数用于让 Docker Compose 在后台运行容器。当你使用 -d 参数时，命令执行后不会阻塞终端，你可以继续在终端中执行其他命令
    // --pull=always 该参数指定在启动容器之前，总是尝试拉取最新的镜像
    "docker:prod:up": "docker compose -f docker-compose.prod.yml --env-file .env --env-file .env.production up -d --pull=always",
    // 停止并删除 Docker Compose 文件中定义的所有服务的容器和网络
    // 默认不删除镜像和卷，主要清理容器和网络资源
    "docker:down": "docker compose --env-file .env --env-file .env.production down",
    // 停止、移除 nest-admin-server 容器，并删除对应的镜像，不会影响其他服务的容器和镜像
    "docker:rmi": "docker compose --env-file .env --env-file .env.production stop nest-admin-server && docker container rm nest-admin-server && docker rmi nest-admin-server",
    // 实时查看由 Docker Compose 管理的多容器应用的日志输出(控制台) -f = --follow
    "docker:logs": "docker compose --env-file .env --env-file .env.production logs -f"
  },
  "pnpm": {
    "peerDependencyRules": {
      "allowedVersions": {}
    }
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "moduleNameMapper": {
      "^~/(.*)$": "<rootDir>/$1"
    },
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  },
  "simple-git-hooks": {
    "pre-commit": "pnpm lint-staged"
  },
  "lint-staged": {
    "*": "eslint --fix"
  }
}